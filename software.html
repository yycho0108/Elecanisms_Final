<!DOCTYPE HTML>
<!--
	Forty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<head>
    <title>Software</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
    <!--[if lte IE 8]>
    <script src="assets/js/ie/html5shiv.js"></script><![endif]-->
    <link rel="stylesheet" href="assets/css/main.css"/>
    <!--[if lte IE 9]>
    <link rel="stylesheet" href="assets/css/ie9.css"/><![endif]-->
    <!--[if lte IE 8]>
    <link rel="stylesheet" href="assets/css/ie8.css"/><![endif]-->
    <script src="assets/js/jquery.min.js"></script>

    <script src="assets/js/load-div.js"></script>
    <link rel="icon"
          type="image/png"
          href="./images/icon.png">
</head>
<body>
<div id="div-menu">
</div>

<!-- Wrapper -->
<div id="wrapper">
    <!-- random comment -->
    <!-- Header -->
    <!-- Note: The "styleN" class below should match that of the banner element. -->
    <header id="header" class="alt style5">
        <a href="index.html" class="logo"><strong>Tilt Game</strong> <span> : Elecanisms</span></a>
        <nav>
            <a href="#menu">Menu</a>
        </nav>
    </header>

    <!-- Banner -->
    <!-- Note: The "styleN" class below should match that of the header element. -->
    <section id="banner" class="style5">
        <div class="inner">
							<span class="image">
								<img src="images/pic07.jpg" alt=""/>
							</span>
            <header class="major">
                <h1><i class="fa fa-code-fork"></i> Software</h1>
            </header>
            <div class="content">
                <p>Game Logic and Code</p>
            </div>
        </div>
    </section>

    <!-- Main -->
    <div id="main">

        <!-- One -->
        <section id="one">
            <div class="inner">
                <header class="major">
                    <h2>Overview</h2>
                </header>
                <img src="images/elecanisms_dataflow.svg"/>

                <p>On a high level, we structured our code as a state machine, varying reactions to commands based on
                    the current state of the game. Our main processing unit, the PIC24, is responsible for game
                    management -- i.e. running the state machine, taking input comamnds and interfacing with the
                    obstacle actuators and other sensors. The Raspberry Pi is mostly acting as a peripheral unit that
                    acts as a Driver for Sound Effects and Bluetooth Wii-Board.</p>

                <a href="http://github.com/yycho0108/Elecanisms_Final">View our code Here! <i class="fa fa-github"></i>
                </a>
            </div>
        </section>

        <!-- Two -->
        <section id="two" class="spotlights">
            <section>
                <a href="generic.html" class="image">
                    <img src="images/elecanisms_fsm.svg" alt="" data-position="center center"/>
                </a>

                <div class="content">
                    <div class="inner">
                        <header class="major">
                            <h3>State Machine</h3>
                        </header>
                        <p> Because the game procedure is relatively linear, the state machine did not have to be
                            incredibly complex. In implementation, a number of safety measures, such as regularly
                            surveying the connectivity of the devices, needed to be implemented to ensure the robustness
                            of the system. In execution, each of the states had constructors and destructors, which
                            doesn't natively exist in C, which would run setup and cleanup portions of the execution at
                            each transition phase.</p>
                        <ul class="actions">
                            <li><a href="generic.html" class="button">Learn more</a></li>
                        </ul>
                    </div>
                </div>
            </section>
            <section>
                <!--<a href="generic.html" class="image">
                    <img src="images/elecanisms_dataflow.svg" alt="" data-position="top center"/>
                </a>-->

                <div style="padding: 2em 3em 0.1em 3em ;">
                    <div class="inner">
                        <header class="major">
                            <h3>FSM Workflow</h3>
                        </header>
                        <h4>Idle</h4>

                        <p>When the game first turns on, it connects to the Rasberry Pi. And runs the basic permanent
                            setup
                            code, such as interrupts and servos. At this point, it waits for the Wii Balance Board to be
                            connected, and indicates the instructions on the display screen accordingly. Once all of the
                            connections have been established and verified, it stays idle until a coin is inserted.</p>

                        <h4>Setup</h4>

                        <p>
                            Immediately after the coin is inserted, the code runs all of the transient setup code, such
                            as
                            initializing the variables to expected values. It puts the tilt angle at a neutral position,
                            and
                            closes the ball-release to house the ball until both players are ready.</p>

                        <h4>Wait Player</h4>

                        <p>
                            The game then moves into the state waiting for the Player to be ready. In this state, the
                            game
                            instructs Player 2 to press the start button, then waits for the start interrupt to be
                            triggered
                            by the start button, then continues to the Run state.</p>

                        <h4>Run</h4>

                        <p>This could be said to be the "main" state. In this state, the PIC handles the obstacle
                            controls from Player 2, while also communicating with the Rasberry Pi to get tilt data from
                            the
                            Wii Balance Board and keeping track of the time left in the game.<br/>
                            The obstacle management varies in complexity depending on the obstacle. The center spinner
                            just
                            takes analog data from the linear potentiometer, and feeds it directly to the servo
                            controller
                            to determine the angle. The flippers check to see if each flipper button is pressed, and if
                            they
                            are, sets the servo to the “high” angle, and if not, sets them to the low angle. The
                            trickiest
                            part in this is making sure that the servo turns the correct directions.<br/>
                            The most challenging obstacles to manage were the electromagnet and the control flip. This
                            is
                            due to the fact that these obstacles were timed, and the times for cooldown and active
                            states
                            were different. We used a state machine combined with a timer and a counter keeping track of
                            how
                            many times the timer flag raised to keep track of the time and the state.
                        </p>

                        <h4>End</h4>
                        <p>This is the final state, where the outcome of the game is determined. If the ball reached the
                        goal before the timeout, Player 1 wins; otherwise, Player 2 wins. At any rate, there is only one
                        victor. After a brief moment of congratulating the winner, the game would loop back into idle
                        mode</p>

                    </div>
                </div>
            </section>
            <section>
                <!--<a href="generic.html" class="image">
                    <img src="images/elecanisms_dataflow.svg" alt="" data-position="top center"/>
                </a>-->

                <div style="padding: 2em 3em 0.1em 3em ;">
                    <div class="inner">
                        <header class="major">
                            <h3>Communication</h3>
                        </header>
                        <h4>Bluetooth</h4>

                        <p>
                            We collect weight ratio information from the Wii balance board in order to control the tilt
                            board. Permanently pairing with the Wii balance board turned out to be a greater challenge
                            than we had initially thought; this feature was unreliable and only supported for certain
                            versions of PyBluez(4.99), with a backend Bluez only for Raspbian Wheezy. Because robustness
                            was our priority, we maintained that at the start of each game the board would be re-paired
                            with the Pi.</p>
                        <h4>USB</h4>

                        <p>
                            We use our USB line to primarily transmit information from the Pi to the PIC24, mainly
                            information regarding the tilt angles, board connectivity status, and the IP address for
                            debugging purposes. Initially, we were concerned about the speed of transmission, but it
                            turned out to be fast enough for our purposes.
                        </p>
                        <h4>UART</h4>

                        <p>
                            Because the PIC is a peripheral device, it cannot initiate a connection with the Raspberry
                            Pi. In order to send signals to the Pi, we use the UART communication with a specifically
                            formatted message. This feature is mainly used for triggering sound effects, as well as
                            logging debug information so that the stored log could be examined later.
                        </p>
                        <h4>I2C</h4>

                        <p>
                            In order to communicate with the LCD Display without taking up too much of the pin's
                            bandwidth, we have (scavenged from previous years) an I2C adapter that not only allows for
                            communication with just two digital pins, but with multiple devices at the same time. We
                            also use status messages sparingly, because displaying can take up too much bandwidth,
                            introducing jitter in the servos as a result thereof.
                        </p>
                    </div>
                </div>
            </section>
        </section>

    </div>


    <!-- Contact -->
    <div id="div-contact"></div>

    <!-- Footer -->
    <div id="div-footer"></div>


</div>

<!-- Scripts -->
<script src="assets/js/jquery.scrolly.min.js"></script>
<script src="assets/js/jquery.scrollex.min.js"></script>
<script src="assets/js/skel.min.js"></script>
<script src="assets/js/util.js"></script>
<!--[if lte IE 8]>
<script src="assets/js/ie/respond.min.js"></script><![endif]-->
<script src="assets/js/main.js"></script>

</body>
</html>